\documentclass[aspectratio=169]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\usepackage[listings, minted]{tcolorbox}
\usepackage{smartdiagram}
\usepackage[export]{adjustbox}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=orange!50, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{The Power Of Const}
\author{Markus Hauck (@markus1189)}

\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}
\begin{frame}
  \begin{center}
    \Huge Introduction
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Why This Talk}
  \begin{itemize}
  \item why a whole talk about \texttt{Const}?
  \item one of the ``funny'' datatypes at first sight
  \item not immediately obvious what it is good for
  \item surprisingly, it is many useful usages
  \item this talk shows (some of) them
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \begin{minted}[fontsize=\Large, linenos=false]{haskell}
     newtype Const a b = Const { getConst :: a }
    \end{minted}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Const Datatype}
  \begin{minted}{haskell}
    newtype Const a b = Const { getConst :: a }
  \end{minted}
  \vfill
  \begin{itemize}
  \item two type parameters \texttt{a} and \texttt{b}
  \item \texttt{b} is a phantom type
  \item you can only ever get a value of type \texttt{a} out of it
  \item type level version of the \texttt{const} \textbf{function} that ignores one of
    the two arguments:
  \end{itemize}
  \vspace{5mm}
  \begin{minted}{haskell}
    const :: a -> b -> b
    const x _ = x
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Table Of Contents}
  \begin{itemize}
  \item Functor instance
  \item Applicative instance
  \item Selective Applicative instance
  \item Conclusion
  \end{itemize}
\end{frame}

\section{Functor}
\begin{frame}
  \begin{center}
    \Huge Functor
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Functor Instance}
  \begin{minted}{haskell}
    instance Functor (Const m) where
      fmap _ (Const v) = Const v
  \end{minted}
  \vspace{5mm}
  \begin{minted}{text}
    ghci> c = Const @String @Int "can't touch me"
    ghci> fmap (+1) c
    Const "can't touch me"
  \end{minted}
  \vfill
  \begin{itemize}
  \item unpack and retag (change the phantom type)
  \item \textbf{discards} the function application
  \item but how is this useful?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Use of Const in Twan van Laarhoven Lenses}
  \begin{minted}{haskell}
    type Lens a b = forall f. Functor f => (b -> f b) -> a -> f a
    _1 :: Lens (a, b) a
    _1 f (x1, y) = fmap (\x2 -> (x2, y)) (f x1)
  \end{minted}

  \begin{itemize}
  \item given a functorial function modifier for \texttt{b}
  \item and a ``bigger'' \texttt{a} that you can get a \texttt{b} from
  \item produce a new \texttt{a} with the modified \texttt{b} inside
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementing Getter With Const}
  \begin{minted}{haskell}
    _1 :: Lens (a, b) a
    _1 f (x1, y) = fmap (\x2 -> (x2, y)) (f x1)

    get :: Lens a b -> a -> b
    get l x = getConst (l Const x)
  \end{minted}
  \vfill
  \begin{minted}{haskell}
  get _1 Const (42, 'a')
= getConst (_1 Const (42, 'a'))                 -- Def. of 'get'
= getConst (fmap (\x2 -> (x2, 'a')) (Const 42)) -- Def. of '_1'
= getConst (Const 42)                           -- Def. of 'fmap' for 'Const
= 42                                            -- The Answer!
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Functor}
  \begin{itemize}
  \item first example: Functor for \texttt{Const}
  \item useless at first glance
  \item nice for lenses
  \end{itemize}
\end{frame}

\section{Applicative}
\begin{frame}
  \begin{center}
    \Huge Applicative
  \end{center}
\end{frame}


\begin{frame}
  \frametitle{The Applicative Instance}
  \begin{itemize}
  \item probably one of my favorites
  \item opens up a lot of possibilities
  \item how? connects two very important concepts
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Instance}
  \begin{minted}{haskell}
    instance Applicative (Const m) where
      pure :: a -> Const m a
      pure = _pure

      (<*>) :: Const m (a -> b) -> Const m a -> Const m b
      Const f <*> Const v = _ap
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Instance}
  \begin{minted}{haskell}
    instance Applicative (Const m) where
      pure :: a -> Const m a
      pure _ = Const mempty

      (<*>) :: Const m (a -> b) -> Const m a -> Const m b
      Const f <*> Const v = Const (f <> v)
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Promoting Monoids}
  \begin{itemize}
  \item but what does it \textbf{mean}?
  \item we can use any function working with \texttt{Applicative}s and
    give them \texttt{Monoid}s!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Using Promoted Monoids}
  \begin{itemize}
  \item by using \texttt{traverse} with \texttt{Const} we get \texttt{foldMap}
  \item that's why \texttt{Traversable} is enough to define a \texttt{Foldable} instance
  \item Use \texttt{Const} to statically analyze \texttt{Free Applicative} programs
  \item which accumulates a monoidal value instead of performing actual effects
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Const and Applicative}
  \begin{itemize}
  \item beautiful: \texttt{Const} highlights the relation between
    Applicative and Monoid
  \item you can use \textbf{everything} you know from Monoids and plug it into applicative functions
  \item Applicative laws state that instances have to be monoidal in
    their effects
  \item use \texttt{Const} to ``analyze'' \texttt{Free Applicatives}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item we saw the instance for \texttt{Applicative}
  \item important bridge between \texttt{Monoid} and \texttt{Applicative}
  \item so what about the \texttt{Monad} instance?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
import Data.Functor.Const

instance Monoid a => Monad (Const a) where
  Const x >>= f = f _
  \end{minted}
  \begin{minted}{text}
const-monad.hs:4:23: error:
    • Found hole: _ :: Const a b
...
    • Relevant bindings include
        f :: a1 -> Const a b (bound at const-monad.hs:4:19)
        x :: a (bound at const-monad.hs:4:12)
        c :: Const a a1 (bound at const-monad.hs:4:3)
...
  \end{minted}
  \begin{itemize}
  \item \texttt{mempty} would typecheck, but violate the left-identity law
  \item we simply can't ``pretend'' anymore
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item somewhere between \texttt{Applicative} and \texttt{Monad}\ldots
  \item Selective Functors!
  \end{itemize}
\end{frame}

\section{Selective}
\begin{frame}
  \begin{center}
    \Huge Selective
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \includegraphics[width=0.77\textwidth]{static-images/selective-applicative-functors-paper.jpg}
    \vfill
    \href{https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf}{https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf}
  \end{center}
\end{frame}

\begin{frame}
    \begin{quote}
    This paper introduces an intermediate abstraction called
    \textit{selective applicative functors} that requires all effects
    to be \textbf{declared statically}, but provides a way to select which of
    the effects to \textbf{execute dynamically}.
  \end{quote}

  \begin{itemize}
  \item (emphasis mine)
  \item offer some of the benefits of Arrows, less powerful
  \item structure of effects still \textbf{statically} fixed, but still \textbf{dynamically} reconfigurable
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Selective Functors}
  \begin{minted}{haskell}
class Applicative f => Selective f where
  select :: f (Either a b) -> f (a -> b) -> f b
  \end{minted}
  \vspace{5mm}
  \begin{itemize}
  \item what does it buy me?
  \item you can branch on \textbf{Bool}s that are inside an ``effect''\footnote{``effect'' with the usual caveats}
    % TODO: code example, e.g. checkFoo
  \end{itemize}
  \begin{minted}{haskell}
    ifS :: Selective f => f Bool -> f a -> f a -> f a
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Selective Functors}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item now the interesting part: how does the instance for \texttt{Const} work?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Selective Instance}
  \begin{minted}{haskell}
newtype Over m a = Over { getOver :: m }

newtype Under m a = Under { getUnder :: m }
  \end{minted}
  \vfill
  \begin{itemize}
  \item with \texttt{Selective} we have two use cases
  \item \texttt{Over} for static \textbf{over}-approximation
  \item \texttt{Under} for static \textbf{under}-approximation
  \end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}
  \begin{center}
    \Huge Conclusion
  \end{center}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item deceptively easy data type
  \item very useful instances that have surprising usages
  \item important tool to understand e.g. Monoidal aspects of
    Applicatives
  \item also easy to highlight the difference between monadic and
    applicative capabilities
  \end{itemize}
\end{frame}

\begin{frame}
  \Huge{}
  Questions?
\end{frame}

\appendix{}

\end{document}
