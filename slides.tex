\documentclass[aspectratio=169]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\usepackage[listings, minted]{tcolorbox}
\usepackage{smartdiagram}
\usepackage[export]{adjustbox}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=orange!50, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{The Power Of Const}
\author{Markus Hauck (@markus1189)}

\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
  \frametitle{Why This Talk}
  \begin{itemize}
  \item when you learn about it \texttt{Const} is one of the ``funny'' datatypes
  \item not immediately obvious what it is good for
  \item surprisingly, it is many useful usages
  \item this talk shows (some of) them
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \begin{minted}[fontsize=\Large, linenos=false]{haskell}
     newtype Const a b = Const { getConst :: a }
    \end{minted}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Const Datatype}
  \begin{minted}{haskell}
    newtype Const a b = Const { getConst :: a }
  \end{minted}
  \vfill
  \begin{itemize}
  \item two type parameters \texttt{a} and \texttt{b}
  \item \texttt{b} is a phantom type
  \item you can only ever get a value of type \texttt{a} out of it
  \item type level version of the \texttt{const} \textbf{function} that ignores one of
    the two arguments:
  \end{itemize}
  \begin{minted}{haskell}
    const :: a -> b -> b
    const x _ = x
  \end{minted}
\end{frame}

\section{Lens (Functor)}

\begin{frame}[fragile]
  \frametitle{The Functor Instance}
  \begin{minted}{haskell}
    instance Functor (Const m) where
      fmap _ (Const v) = Const v
  \end{minted}
  \vfill
  \begin{itemize}
  \item unpack and retag
  \item discards the function application
  \item but how is this useful?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Use of Const in Twan van Laarhoven Lenses}
  \begin{minted}{haskell}
    type Lens a b = forall f. Functor f => (b -> f b) -> a -> f a
    _1 :: Lens (a, b) a
    _1 f (x1, y) = fmap (\x2 -> (x2, y)) (f x1)
  \end{minted}

  \begin{itemize}
  \item given a functorial function modifier for \texttt{b}
  \item and a ``bigger'' \texttt{a} that you can get a \texttt{b} from
  \item produce a new \texttt{a} with the modified \texttt{b} inside
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item use \texttt{Const} to implement the \texttt{getter}
  \end{itemize}

  \begin{minted}{haskell}
    forall f. Functor f => (b -> f b) -> (a -> f a)
    (b -> f b) -> (a -> f a)
  \end{minted}
\end{frame}

\section{Applicative}

\begin{frame}
  \frametitle{The Applicative Instance}
  \begin{itemize}
  \item probably one of my favorites
  \item opens up a lot of possibilities
  \item how? connects two very important concepts
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Instance}
  \begin{minted}{haskell}
    instance Applicative (Const m) where
      pure :: a -> Const m a
      pure x = _pure

    (<*>) :: Const m (a -> b) -> Const m a -> Const m b
    Const f <*> Const v = _ap
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Instance}
  \begin{minted}{haskell}
    instance Monoid m => Applicative (Const m) where
      pure _ = Const mempty
      Const f <*> Const v = Const (f <> v)
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Promoting Monoids}
\end{frame}

\begin{frame}
  \frametitle{Using Promoted Monoids}
  \begin{itemize}
  \item by using \texttt{traverse} with \texttt{Const} we get \texttt{foldMap}
  \item that's why \texttt{Traversable} is enough to define a \texttt{Foldable} instance
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Const and Applicative}
  \begin{itemize}
  \item beautiful: \texttt{Const} highlights the relation between
    Applicative and Monoid
  \item you can use \textbf{everything} you know from Monoids and plug it into applicative functions
  \item Applicative laws state that instances have to be monoidal in
    their effects
  \item use \texttt{Const} to ``analyze'' \texttt{Free Applicatives}
  \end{itemize}
\end{frame}

\section{Monad}

\begin{frame}[fragile]
  \begin{itemize}
  \item so what about the monad instance?
  \end{itemize}

  \begin{minted}{haskell}
import Data.Functor.Const

instance Monoid a => Monad (Const a) where
  Const x >>= f = f _
  \end{minted}
  \begin{minted}{text}
const-monad.hs:4:23: error:
    • Found hole: _ :: Const a b
...
    • Relevant bindings include
        f :: a1 -> Const a b (bound at const-monad.hs:4:19)
        x :: a (bound at const-monad.hs:4:12)
        c :: Const a a1 (bound at const-monad.hs:4:3)
...
  \end{minted}
  \begin{itemize}
  \item \texttt{mempty} would typecheck, but violate the left-identity law
  \item we simply can't ``pretend'' anymore
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item somewhere between \texttt{Applicative} and \texttt{Monad}\ldots
  \item Selective Functors!
  \end{itemize}
\end{frame}

\section{Selective}

\begin{frame}[fragile]
  \begin{center}
    \includegraphics[width=0.77\textwidth]{static-images/selective-applicative-functors-paper.jpg}
    \vfill
    % \href{https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf}
  \end{center}
\end{frame}

\begin{frame}
    \begin{quote}
    This paper introduces an intermediate abstraction called
    \textit{selective applicative functors} that requires all effects
    to be \textbf{declared statically}, but provides a way to select which of
    the effects to \textbf{execute dynamically}.
  \end{quote}

  \begin{itemize}
  \item (emphasis mine)
  \item offer some of the benefits of Arrows, less powerful
  \item structure of effects still \textbf{statically} fixed, but still \textbf{dynamically} reconfigurable
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Selective Functors}
  \begin{minted}{haskell}
class Applicative f => Selective f where
  select :: f (Either a b) -> f (a -> b) -> f b
  \end{minted}
  \vspace{5mm}
  \begin{itemize}
  \item what does it buy me? good intuition: \texttt{ifS}
  \item you can branch on \textbf{Bool}s that are inside an ``effect''\footnote{``effect'' with the usual caveats}
    % TODO: code example, e.g. checkFoo
  \end{itemize}
  \begin{minted}{haskell}
    ifS :: Selective f => f Bool -> f a -> f a -> f a
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Selective Functors}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item now the interesting part: how does the instance for \texttt{Const} work?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Selective Instance}
  \begin{minted}{haskell}
newtype Over m a = Over { getOver :: m }

newtype Under m a = Under { getUnder :: m }
  \end{minted}
  \vfill
  \begin{itemize}
  \item with \texttt{Selective} we have two use cases
  \item \texttt{Over} for static \textbf{over}-approximation
  \item \texttt{Under} for static \textbf{under}-approximation
  \end{itemize}
\end{frame}

\section{Conclusion}

\begin{frame}
  \begin{itemize}
  \item deceptively easy data type
  \item very useful instances that have surprising usages
  \item important tool to understand e.g. Monoidal aspects of
    Applicatives
  \item also easy to highlight the difference between monadic and
    applicative capabilities
  \end{itemize}
\end{frame}

\begin{frame}
  \Huge{}
  Questions?
\end{frame}

\appendix{}

\end{document}
